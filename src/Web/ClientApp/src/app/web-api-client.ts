//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthClient {
    login(userName: string | null | undefined, password: string | null | undefined, isPersistent: boolean, lockOutOnFailure: boolean): Observable<ResultOfLoginDto>;
    logOut(userId: string | null | undefined): Observable<ResultOfLogoutDto>;
    geLoggedIn(): Observable<ResultOfGetLoggedInQueryDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(userName: string | null | undefined, password: string | null | undefined, isPersistent: boolean, lockOutOnFailure: boolean): Observable<ResultOfLoginDto> {
        let url_ = this.baseUrl + "/api/Auth/Login?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (isPersistent === undefined || isPersistent === null)
            throw new Error("The parameter 'isPersistent' must be defined and cannot be null.");
        else
            url_ += "IsPersistent=" + encodeURIComponent("" + isPersistent) + "&";
        if (lockOutOnFailure === undefined || lockOutOnFailure === null)
            throw new Error("The parameter 'lockOutOnFailure' must be defined and cannot be null.");
        else
            url_ += "LockOutOnFailure=" + encodeURIComponent("" + lockOutOnFailure) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfLoginDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfLoginDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResultOfLoginDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfLoginDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logOut(userId: string | null | undefined): Observable<ResultOfLogoutDto> {
        let url_ = this.baseUrl + "/api/Auth/LogOut?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfLogoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfLogoutDto>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<ResultOfLogoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfLogoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    geLoggedIn(): Observable<ResultOfGetLoggedInQueryDto> {
        let url_ = this.baseUrl + "/api/Auth/GeLoggedIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeLoggedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeLoggedIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetLoggedInQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetLoggedInQueryDto>;
        }));
    }

    protected processGeLoggedIn(response: HttpResponseBase): Observable<ResultOfGetLoggedInQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetLoggedInQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IForecastsClient {
    getAllForcast(): Observable<GetAllForecastQueryDto[]>;
    createForecast(command: CreateForecastCommand): Observable<ResultOfCreateForecastCommandDto>;
    updateForecast(command: UpdateForecastCommand): Observable<ResultOfUpdateForecastCommandDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ForecastsClient implements IForecastsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllForcast(): Observable<GetAllForecastQueryDto[]> {
        let url_ = this.baseUrl + "/api/Forecasts/GetAllForcast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForcast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForcast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllForecastQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllForecastQueryDto[]>;
        }));
    }

    protected processGetAllForcast(response: HttpResponseBase): Observable<GetAllForecastQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllForecastQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createForecast(command: CreateForecastCommand): Observable<ResultOfCreateForecastCommandDto> {
        let url_ = this.baseUrl + "/api/Forecasts/CreateForecast";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateForecastCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateForecastCommandDto>;
        }));
    }

    protected processCreateForecast(response: HttpResponseBase): Observable<ResultOfCreateForecastCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateForecastCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateForecast(command: UpdateForecastCommand): Observable<ResultOfUpdateForecastCommandDto> {
        let url_ = this.baseUrl + "/api/Forecasts/UpdateForecast";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateForecastCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateForecastCommandDto>;
        }));
    }

    protected processUpdateForecast(response: HttpResponseBase): Observable<ResultOfUpdateForecastCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateForecastCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUsersClient {
    allUsersByName(searchValue: string | null | undefined, pageNumber: number, pageSize: number): Observable<ResultOfUsersListDto>;
    getUserByID(id: string | null | undefined): Observable<ResultOfUserByIDDto>;
    createIdentityUser(command: CreateUserCommand): Observable<ResultOfCreateUserDto>;
    updateIdentityUser(command: UpdateUserCommand): Observable<ResultOfUpdateUserDto>;
    updatePassword(command: UpdatePasswordCommand): Observable<ResultOfUpdatePasswordDto>;
    getPassword(): Observable<ResultOfGeneratePasswordDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    allUsersByName(searchValue: string | null | undefined, pageNumber: number, pageSize: number): Observable<ResultOfUsersListDto> {
        let url_ = this.baseUrl + "/api/Users/AllUsersByName?";
        if (searchValue !== undefined && searchValue !== null)
            url_ += "SearchValue=" + encodeURIComponent("" + searchValue) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllUsersByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllUsersByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUsersListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUsersListDto>;
        }));
    }

    protected processAllUsersByName(response: HttpResponseBase): Observable<ResultOfUsersListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUsersListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserByID(id: string | null | undefined): Observable<ResultOfUserByIDDto> {
        let url_ = this.baseUrl + "/api/Users/GetUserByID?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUserByIDDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUserByIDDto>;
        }));
    }

    protected processGetUserByID(response: HttpResponseBase): Observable<ResultOfUserByIDDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserByIDDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createIdentityUser(command: CreateUserCommand): Observable<ResultOfCreateUserDto> {
        let url_ = this.baseUrl + "/api/Users/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateUserDto>;
        }));
    }

    protected processCreateIdentityUser(response: HttpResponseBase): Observable<ResultOfCreateUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateIdentityUser(command: UpdateUserCommand): Observable<ResultOfUpdateUserDto> {
        let url_ = this.baseUrl + "/api/Users/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateUserDto>;
        }));
    }

    protected processUpdateIdentityUser(response: HttpResponseBase): Observable<ResultOfUpdateUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePassword(command: UpdatePasswordCommand): Observable<ResultOfUpdatePasswordDto> {
        let url_ = this.baseUrl + "/api/Users/UpdatePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdatePasswordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdatePasswordDto>;
        }));
    }

    protected processUpdatePassword(response: HttpResponseBase): Observable<ResultOfUpdatePasswordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdatePasswordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPassword(): Observable<ResultOfGeneratePasswordDto> {
        let url_ = this.baseUrl + "/api/Users/GenerateRandomPassword";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGeneratePasswordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGeneratePasswordDto>;
        }));
    }

    protected processGetPassword(response: HttpResponseBase): Observable<ResultOfGeneratePasswordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGeneratePasswordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ResultOfLoginDto implements IResultOfLoginDto {
    data?: LoginDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfLoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LoginDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfLoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfLoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfLoginDto {
    data?: LoginDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class LoginDto implements ILoginDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ILoginDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export enum ResultType {
    Success = 1,
    Warning = 2,
    Error = 3,
    Information = 4,
}

export class ResultOfLogoutDto implements IResultOfLogoutDto {
    data?: LogoutDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfLogoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LogoutDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfLogoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfLogoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfLogoutDto {
    data?: LogoutDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class LogoutDto implements ILogoutDto {
    userId?: string | undefined;
    time?: Date | undefined;

    constructor(data?: ILogoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LogoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILogoutDto {
    userId?: string | undefined;
    time?: Date | undefined;
}

export class ResultOfGetLoggedInQueryDto implements IResultOfGetLoggedInQueryDto {
    data?: GetLoggedInQueryDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGetLoggedInQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetLoggedInQueryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGetLoggedInQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetLoggedInQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGetLoggedInQueryDto {
    data?: GetLoggedInQueryDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GetLoggedInQueryDto implements IGetLoggedInQueryDto {
    loggedInId?: string | undefined;

    constructor(data?: IGetLoggedInQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedInId = _data["loggedInId"];
        }
    }

    static fromJS(data: any): GetLoggedInQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLoggedInQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedInId"] = this.loggedInId;
        return data;
    }
}

export interface IGetLoggedInQueryDto {
    loggedInId?: string | undefined;
}

export class GetAllForecastQueryDto implements IGetAllForecastQueryDto {
    id?: number | undefined;
    forecastName?: string | undefined;
    city?: string | undefined;
    temperature?: string | undefined;
    forecastDescription?: string | undefined;
    forecastDate?: string | undefined;
    forecastMain?: string | undefined;
    pressure?: string | undefined;
    humidity?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetAllForecastQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.forecastName = _data["forecastName"];
            this.city = _data["city"];
            this.temperature = _data["temperature"];
            this.forecastDescription = _data["forecastDescription"];
            this.forecastDate = _data["forecastDate"];
            this.forecastMain = _data["forecastMain"];
            this.pressure = _data["pressure"];
            this.humidity = _data["humidity"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetAllForecastQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllForecastQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["forecastName"] = this.forecastName;
        data["city"] = this.city;
        data["temperature"] = this.temperature;
        data["forecastDescription"] = this.forecastDescription;
        data["forecastDate"] = this.forecastDate;
        data["forecastMain"] = this.forecastMain;
        data["pressure"] = this.pressure;
        data["humidity"] = this.humidity;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetAllForecastQueryDto {
    id?: number | undefined;
    forecastName?: string | undefined;
    city?: string | undefined;
    temperature?: string | undefined;
    forecastDescription?: string | undefined;
    forecastDate?: string | undefined;
    forecastMain?: string | undefined;
    pressure?: string | undefined;
    humidity?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfCreateForecastCommandDto implements IResultOfCreateForecastCommandDto {
    data?: CreateForecastCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateForecastCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateForecastCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateForecastCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateForecastCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateForecastCommandDto {
    data?: CreateForecastCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateForecastCommandDto implements ICreateForecastCommandDto {
    id?: string | undefined;
    createdDate?: Date;

    constructor(data?: ICreateForecastCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateForecastCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateForecastCommandDto {
    id?: string | undefined;
    createdDate?: Date;
}

export class CreateForecastCommand implements ICreateForecastCommand {
    forecastName?: string | undefined;
    city?: string | undefined;
    temperature?: string | undefined;
    forecastDescription?: string | undefined;
    forecastDate?: string | undefined;
    forecastMain?: string | undefined;
    pressure?: string | undefined;
    humidity?: string | undefined;

    constructor(data?: ICreateForecastCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.forecastName = _data["forecastName"];
            this.city = _data["city"];
            this.temperature = _data["temperature"];
            this.forecastDescription = _data["forecastDescription"];
            this.forecastDate = _data["forecastDate"];
            this.forecastMain = _data["forecastMain"];
            this.pressure = _data["pressure"];
            this.humidity = _data["humidity"];
        }
    }

    static fromJS(data: any): CreateForecastCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastName"] = this.forecastName;
        data["city"] = this.city;
        data["temperature"] = this.temperature;
        data["forecastDescription"] = this.forecastDescription;
        data["forecastDate"] = this.forecastDate;
        data["forecastMain"] = this.forecastMain;
        data["pressure"] = this.pressure;
        data["humidity"] = this.humidity;
        return data;
    }
}

export interface ICreateForecastCommand {
    forecastName?: string | undefined;
    city?: string | undefined;
    temperature?: string | undefined;
    forecastDescription?: string | undefined;
    forecastDate?: string | undefined;
    forecastMain?: string | undefined;
    pressure?: string | undefined;
    humidity?: string | undefined;
}

export class ResultOfUpdateForecastCommandDto implements IResultOfUpdateForecastCommandDto {
    data?: UpdateForecastCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateForecastCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateForecastCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateForecastCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateForecastCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateForecastCommandDto {
    data?: UpdateForecastCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateForecastCommandDto implements IUpdateForecastCommandDto {
    id?: string | undefined;
    updatedDate?: Date;

    constructor(data?: IUpdateForecastCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateForecastCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateForecastCommandDto {
    id?: string | undefined;
    updatedDate?: Date;
}

export class UpdateForecastCommand implements IUpdateForecastCommand {
    uniqueId?: string | undefined;
    forecastName?: string | undefined;
    city?: string | undefined;
    temperature?: string | undefined;
    forecastDescription?: string | undefined;
    forecastDate?: string | undefined;
    forecastMain?: string | undefined;
    pressure?: string | undefined;
    humidity?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateForecastCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueId = _data["uniqueId"];
            this.forecastName = _data["forecastName"];
            this.city = _data["city"];
            this.temperature = _data["temperature"];
            this.forecastDescription = _data["forecastDescription"];
            this.forecastDate = _data["forecastDate"];
            this.forecastMain = _data["forecastMain"];
            this.pressure = _data["pressure"];
            this.humidity = _data["humidity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateForecastCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueId"] = this.uniqueId;
        data["forecastName"] = this.forecastName;
        data["city"] = this.city;
        data["temperature"] = this.temperature;
        data["forecastDescription"] = this.forecastDescription;
        data["forecastDate"] = this.forecastDate;
        data["forecastMain"] = this.forecastMain;
        data["pressure"] = this.pressure;
        data["humidity"] = this.humidity;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateForecastCommand {
    uniqueId?: string | undefined;
    forecastName?: string | undefined;
    city?: string | undefined;
    temperature?: string | undefined;
    forecastDescription?: string | undefined;
    forecastDate?: string | undefined;
    forecastMain?: string | undefined;
    pressure?: string | undefined;
    humidity?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfUsersListDto implements IResultOfUsersListDto {
    data?: UsersListDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UsersListDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUsersListDto {
    data?: UsersListDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UsersListDto implements IUsersListDto {
    users?: UsersDto[] | undefined;

    constructor(data?: IUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UsersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUsersListDto {
    users?: UsersDto[] | undefined;
}

export class UsersDto implements IUsersDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUsersDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUserByIDDto implements IResultOfUserByIDDto {
    data?: UserByIDDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUserByIDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserByIDDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUserByIDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUserByIDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUserByIDDto {
    data?: UserByIDDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UserByIDDto implements IUserByIDDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUserByIDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UserByIDDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserByIDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUserByIDDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfCreateUserDto implements IResultOfCreateUserDto {
    data?: CreateUserDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateUserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateUserDto {
    data?: CreateUserDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateUserDto implements ICreateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ICreateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    userName?: string | undefined;
    password?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ICreateUserCommand {
    userName?: string | undefined;
    password?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUpdateUserDto implements IResultOfUpdateUserDto {
    data?: UpdateUserDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateUserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateUserDto {
    data?: UpdateUserDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateUserDto implements IUpdateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUpdateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUpdateUserCommand {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUpdatePasswordDto implements IResultOfUpdatePasswordDto {
    data?: UpdatePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdatePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdatePasswordDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdatePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdatePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdatePasswordDto {
    data?: UpdatePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdatePasswordDto implements IUpdatePasswordDto {
    id?: string | undefined;
    updatedDate?: Date | undefined;

    constructor(data?: IUpdatePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdatePasswordDto {
    id?: string | undefined;
    updatedDate?: Date | undefined;
}

export class UpdatePasswordCommand implements IUpdatePasswordCommand {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IUpdatePasswordCommand {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class ResultOfGeneratePasswordDto implements IResultOfGeneratePasswordDto {
    data?: GeneratePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGeneratePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GeneratePasswordDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGeneratePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGeneratePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGeneratePasswordDto {
    data?: GeneratePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GeneratePasswordDto implements IGeneratePasswordDto {
    password?: string | undefined;

    constructor(data?: IGeneratePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GeneratePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }
}

export interface IGeneratePasswordDto {
    password?: string | undefined;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}